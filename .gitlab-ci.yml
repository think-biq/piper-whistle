# The Docker image that will be used to build your app
image: thinkbiq/ue-plugin-staging:latest

stages:
  - pre-release-test
  - release
  - post-release-test
  - finalize

test-functional:
  stage: pre-release-test
  script:
    - pip install -U pip
    - pip install -r requirements.dev.txt
    - pip install -r requirements.txt
    - python3 -m unittest src/testing/functional.py
  rules:
    # This ensures that only pushes to the default branch are considered.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      allow_failure: true
    # This ensures that only pushes to the staging / testing branch
    - if: $CI_COMMIT_REF_NAME == "staging"
      allow_failure: true

test-release-pypi-test:
  stage: post-release-test
  script:
    - pip install -U pip
    - pip install --index-url https://test.pypi.org/simple/ piper-whistle
    - piper_whistle -h
    - piper_whistle -vR
    - |
      [ "hu_HU" = "$(piper_whistle guess hung)" ]
      && echo Found hungarian language support
      || exit 13
    - piper_whistle list -U -l hu_HU -i 0
    - piper_whistel install hu_HU 0
    - |
      piper_whistel path
      $(piper_whistel list -S -l hu_HU -i 0 | awk '{ print $1 }')
  rules:
    # This ensures that only pushes to the default branch are considered.
    - if: $CI_COMMIT_REF_NAME == "staging"
      allow_failure: true

release-pypi-test:
  stage: release
  script:
    - pip install -U pip
    - pip install -r requirements.dev.txt
    - pip install -r requirements.txt
    - mkdir -p build/release
    - python3 -m build -s -w -o build/release
    - twine upload --config-file ${PYPI_CONFIG_FILE} -r testpypi build/release/*
  rules:
    # This ensures that only pushes to the staging / testing branch
    - if: $CI_COMMIT_REF_NAME == "staging"
      allow_failure: true
    # or main branch are considered.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true

release-pypi:
  stage: release
  script:
    - pip install -U pip
    - pip install -r requirements.dev.txt
    - pip install -r requirements.txt
    - mkdir -p build/release
    - python3 -m build -s -w -o build/release
    - twine upload --config-file ${PYPI_LIVE_CONFIG_FILE} build/release/*
  rules:
    # This ensures that only pushes to the release branch trigger sync.
    - if: $CI_COMMIT_REF_NAME == "release"
      allow_failure: true

pages:
  stage: finalize
  script:
    - echo "Building documentation ..."
    - make -C docs
    - echo "Exposing as public ..."
    - mv docs/published public
    - echo "Result:"
    - ls -lav public
    - echo "Hosting ..."
  artifacts:
    paths:
      # The folder that contains the files to be exposed at the Page URL
      - public
  rules:
    # This ensures that only pushes to the release branch trigger sync.
    - if: $CI_COMMIT_REF_NAME == "release"
      allow_failure: true
    # or main branch are considered.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true

sync:
  stage: finalize
  script:
    - apt-get update -y
    - apt-get install -yqqf openssh-client sshpass --fix-missing
    - eval $(ssh-agent -s)
    - cat "${GITHUB_DEPLOY_KEY_FILE}" | tr -d '\r' | ssh-add - > /dev/null
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan ${GITHUB_DEPLOY_DOMAIN} >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
    - git config --global user.email "${GITHUB_USER_EMAIL}"
    - git config --global user.name "${GITHUB_USER_NAME}"
    - git remote rm origin 2> /dev/null
    - git remote add origin ${GITHUB_REPO_LINK}
    - git push --all
    - git push --tags
  rules:
    # This ensures that only pushes to the release branch trigger sync.
    - if: $CI_COMMIT_REF_NAME == "release"
      allow_failure: true
    # or main branch are considered.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true
